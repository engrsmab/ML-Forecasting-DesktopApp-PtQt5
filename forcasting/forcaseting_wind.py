import time,numpy as np
from threading import Thread
from data_thread import Ui_MainWindow,Worker,ProgressBar,QThreadPool,QtWidgets,db_Class,forcaseting_thread,prediction_thread
from forcasting.forcasting import forcasting,datetime
from Qt_Dialogues import *
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
class MplCanvas(FigureCanvasQTAgg):
    """
    This class is used to plot graphs
    width: width of graph figure
    height: height of graph figur
    dpi: Dots per Inch
    title: Title of the figure
    
    """
    def __init__(self, parent=None, width=5, height=3, dpi=90,title=None,xlabel=None,ylabel=None):
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        self.axes = self.fig.add_subplot(111)

        self.axes.set_title(title)
       
        super(MplCanvas, self).__init__(self.fig)
class Forcaseting_window:
    def __init__(self) -> None:
       
        self.filters = [[],[],[],[]]
        self.filter_state = False
        self.update = False
        self.forcasting_plot_list = None
        self.f_states_check_list = None
        self.f_type_check_list = None
        self.f_date_list = None
        self.data = None


        self.t = ["Daily Incident Trend","Count of Incident by priority","Count of Incident by State","Count of Incident by Type","Generated By"]
        self.x = ["sys_updated","priority_lagend","state_lagend","type_lagend","generated_lagend"]
        self.y = ["group_list","priority_value","state_value","type_value","generated_value"]

        self.forcasting_class = forcasting()
        self.date_format = self.forcasting_class.date_format
  
        # Setting Dates
        self.today_date = self.forcasting_class.today_date
        self.today_time = datetime.datetime.now().strftime("%H:%M:%S")
        self.f_date = (self.forcasting_class.date + datetime.timedelta(days=60)).strftime("%Y-%m-%d")
        self.f_time = (self.forcasting_class.date + datetime.timedelta(days=60)).strftime("%H:%M:%S")
        self.dot_img = None
        self.forcasting_label = None

        self.pool = QThreadPool.globalInstance()
    def start_thread(self):
        dot_thread = Thread(target=self.dot_loading)
        dot_thread.start()
    def filter_toggled(self,event,x,text,state):
        if state.isChecked():
            if text not in self.filters[x]:
                self.filters[x].append(text)
                self.filter_status = True
                print(f"Applied Filter: {text}")
        else:
            if text in self.filters[x]:
                self.filters[x].remove(text)
                if len(self.filters[x]) == 0:
                    self.filter_status = False
                print(f"Removed Filter: {text}")
        print("Total Filters: ",self.filters)
        
        self.update = True
        self.predict("Predicting Data")

    def get_date_interval(self):
        """
        Function to get value of Start & End Time Calender
        """
        
        self.start_date =datetime.datetime.strptime(self.f_date_list[0].date().toPyDate().strftime(self.date_format),self.date_format).date()
        self.end_date = datetime.datetime.strptime(self.f_date_list[1].date().toPyDate().strftime(self.date_format),self.date_format).date()
        self.date_interval = (self.end_date - self.start_date).days
    def dot_loading(self):
        while True:
            self.dot_img.hide()
            time.sleep(0.5)
            self.dot_img.show()
            time.sleep(0.5)
    def forcasting_func(self,data):
        self.get_date_interval()
        self.forcasting_label.setText("Training Data")
        
        self.forcasting_class.df = data
        self.forcasting_class.df = self.forcasting_class.df.replace(np.nan,str(0))
        self.forcasting_class.date_interval = self.date_interval
        
        
        training_process = forcaseting_thread(self.forcasting_class)
        training_process.signal.training_label.connect(self.predict)
        self.pool.start(training_process)
    def change_date(self,event):
        self.predict("Predicting Data",True)
    def predict(self,text,date=False):
        if date:
            self.get_date_interval()
            self.forcasting_class.date_interval = self.date_interval
        self.forcasting_label.setText(text)
        prediction = prediction_thread(self.forcasting_class,self.filters)
        prediction.signal.forcasted_data.connect(self.plot)
        self.pool.start(prediction)

    def plot(self,final_data):
        self.forcasting_label.setText("Forcasting Data")

        

        if len(final_data[0].index) == 0:
            error_dialog("Data Error","No Data Found for applied filter","")
            return None
        count = 0
        prog_count = 50
        if not self.update:
            self.sc_list = []
            self.graph_list = []
        for graph in self.forcasting_plot_list:
            if not self.update:
                sc = MplCanvas(self, title=self.t[count])
                sc_option = sc
            else:
                self.sc_list[count].axes.clear()
                sc_option = self.sc_list[count]
            if count == 0:
                # print("Bar Chart Data: ",final_data[count])
                graph_value = final_data[count].plot(ax=sc_option.axes,kind="bar")    
                 
                
                positions = [0,len(final_data[count].index)//3,len(final_data[count].index)//2,int(len(final_data[count].index)//1.2),len(final_data[count].index)-1]
                xlbls = [str(final_data[count].index[i]).split(" ")[0] for i in positions]
                if self.update:
                    self.graph_list[count].set_xticks(positions)
                    self.graph_list[count].set_xticklabels(xlbls,rotation=15)
                else:
                    graph_value.set_xticks(positions)
                    graph_value.set_xticklabels(xlbls,rotation=15)
                    sc.axes.legend(loc='upper left',ncol=3)
                    sc.axes.set_ylabel("Count of Assignment Group")
                    sc.axes.set_xlabel("System Updated On")
            else:
                df = final_data[count][self.y[count]].value_counts()
                graph_value = df.plot.pie(ax=sc_option.axes,ylabel='',labeldistance=None)
                if not self.update:
                    graph_value.legend(bbox_to_anchor=(0.64, 1.05), loc='upper left')
                else:
                    self.graph_list[count].legend(bbox_to_anchor=(0.64, 1.05), loc='upper left')
            if self.update:
                self.sc_list[count].draw()
                self.sc_list[count].flush_events()
            else:
 
                # self.plotted.append(graph_value)
                layout = QtWidgets.QHBoxLayout(graph)
                layout.setContentsMargins(0, 0, 0, 0)
                layout.setSpacing(0)
                layout.addWidget(sc_option)

                # self.plot_sc.append(self.sc)
            count += 1
            prog_count += 5
            # self.progress_change.update(prog_count)
            if not self.update:
                self.sc_list.append(sc)
                self.graph_list.append(graph_value)

